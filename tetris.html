<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tetris Game</title>
  <style>
    body {
      background: #181824;
      color: #fff;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
    }
    .tetris-container {
      display: flex;
      flex-direction: row;
      align-items: flex-start;
      justify-content: center;
    }
    .side-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-left: 24px;
      margin-right: 24px;
    }
    .panel-label {
      font-size: 1em;
      color: #aaa;
      margin-bottom: 4px;
      margin-top: 12px;
    }
    #tetris {
      background: #222;
      border: 4px solid #444;
      box-shadow: 0 0 20px #000a;
      display: block;
      margin-bottom: 10px;
    }
    #next, #hold {
      background: #222;
      border: 2px solid #444;
      margin-bottom: 10px;
      display: block;
    }
    #score {
      font-size: 1.2em;
      margin-bottom: 10px;
    }
    #controls {
      font-size: 1em;
      color: #aaa;
      margin-bottom: 10px;
    }
    button {
      background: #444;
      color: #fff;
      border: none;
      padding: 8px 16px;
      margin: 0 5px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 1em;
    }
    button:hover {
      background: #666;
    }
    h1 {
      margin-bottom: 2px;
      font-size: 2em;
      letter-spacing: 2px;
    }
    #startMenu {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      background: #111;
      border: 1px solid #333;
      padding: 16px 18px;
      border-radius: 8px;
      box-shadow: 0 6px 24px rgba(0,0,0,0.6);
    }
  </style>
</head>
<body>
  <h1>Antris</h1>
  <div style="color:#aaa; margin-top:0; margin-bottom:6px; font-size:0.95em;">powered by Cock Engine</div>
  <div id="score">Score: 0</div>
  <div id="modeStatus" style="color:#bbb; margin-bottom:10px; font-size:0.95em;"></div>
  <div class="tetris-container">
    <div class="side-panel">
      <div class="panel-label">Hold</div>
      <canvas id="hold" width="96" height="96"></canvas>
    </div>
    <canvas id="tetris" width="240" height="480"></canvas>
    <div class="side-panel">
      <div class="panel-label">Next</div>
      <canvas id="next" width="96" height="288"></canvas>
    </div>
  </div>
  <div id="startMenu" style="background:#111; border:1px solid #333; padding:16px 18px; border-radius:8px; box-shadow:0 6px 24px rgba(0,0,0,0.6); margin-bottom:12px;">
    <div style="font-weight:bold; margin-bottom:10px;">Choose Mode</div>
    <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center; align-items:center; margin-bottom:8px;">
      <button id="btn40" style="background:#2b2b3b; padding:8px 14px; border-radius:6px;">40 Lines</button>
      <button id="btnBlitz" style="background:#2b2b3b; padding:8px 14px; border-radius:6px;">Blitz (2:00)</button>
      <a href="index.html" style="background:#444; color:#fff; text-decoration:none; padding:8px 14px; border-radius:6px; display:inline-block;">Back to Home</a>
    </div>
    <div style="display:flex; gap:8px; align-items:center; justify-content:center;">
      <input type="checkbox" id="toggleSpeed" checked>
      <label for="toggleSpeed" style="color:#bbb;">Speed up after each piece</label>
      <input type="checkbox" id="toggleMusic" checked>
      <label for="toggleMusic" style="color:#bbb;">Music</label>
    </div>
    <div style="color:#888; font-size:0.9em; margin-top:8px; text-align:center;">40 Lines: clear 40 lines as fast as possible. Blitz: clear as many lines as you can in 2 minutes.</div>
  </div>
  <div id="controls">
    Controls: ← → (move), ↑ (rotate), ↓ (soft drop), Space (hard drop), R (restart), Hold: Shift or C
  </div>
  <div id="error" style="color:#ff4c4c; font-weight:bold; margin-top:10px;"></div>
  <script>
    // --- TETRIS CONSTANTS ---
    const COLS = 10;
    const ROWS = 20;
    const BLOCK = 24;
    const COLORS = [
      null,
      '#FF0D72', // T
      '#0DC2FF', // I
      '#0DFF72', // S
      '#F538FF', // Z
      '#FF8E0D', // L
      '#FFE138', // O
      '#3877FF'  // J
    ];
    const SHAPES = [
      [],
      [ // T
        [0, 1, 0],
        [1, 1, 1],
        [0, 0, 0]
      ],
      [ // I
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
      ],
      [ // S
        [0, 1, 1],
        [1, 1, 0],
        [0, 0, 0]
      ],
      [ // Z
        [1, 1, 0],
        [0, 1, 1],
        [0, 0, 0]
      ],
      [ // L
        [0, 0, 1],
        [1, 1, 1],
        [0, 0, 0]
      ],
      [ // O
        [1, 1],
        [1, 1]
      ],
      [ // J
        [1, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
      ]
    ];
    // Add this after the SHAPES array:
    const WALL_KICKS = {
      standard: [
        [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2], [1, 0], [1, 1], [0, 2], [1, -2], [-2, 0]], // 0->1
        [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2], [-1, 0], [-1, -1], [0, -2], [-1, 2], [2, 0]],   // 1->2
        [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2], [-1, 0], [-1, 1], [0, 2], [-1, -2], [-2, 0]],  // 2->3
        [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2], [1, 0], [1, -1], [0, -2], [1, 2], [2, 0]]    // 3->0
      ],
      iPiece: [
        [[0, 0], [-2, 0], [1, 0], [-2, -1], [1, 2], [2, 0], [-1, 0], [2, 1], [-1, -2]],  // 0->1
        [[0, 0], [-1, 0], [2, 0], [-1, 2], [2, -1], [1, 0], [-2, 0], [1, -2], [-2, 1]], // 1->2
        [[0, 0], [2, 0], [-1, 0], [2, 1], [-1, -2], [-2, 0], [1, 0], [-2, -1], [1, 2]], // 2->3
        [[0, 0], [1, 0], [-2, 0], [1, -2], [-2, 1], [-1, 0], [2, 0], [-1, 2], [2, -1]]  // 3->0
      ]
    };

    function getWallKicks(oldMatrix, newMatrix, rotation) {
      const isIPiece = oldMatrix.length === 4 && oldMatrix[1].every(v => v === 1);
      const kicks = isIPiece ? WALL_KICKS.iPiece : WALL_KICKS.standard;
      return kicks[rotation];
    }
    // --- GAME STATE ---
    let arena = createMatrix(COLS, ROWS);
    let player = {
      pos: {x: 0, y: 0},
      matrix: null,
      color: null,
      score: 0,
      rotation: 0 // Add to player object
    };
    let dropCounter = 0;
    let dropInterval = 500;
    let lastTime = 0;
    let gameOver = false;
    let paused = false;
    // Hold-to-restart state
    let restartHoldActive = false;
    let restartHoldStart = 0;
    let restartHoldMs = 3000;
    let restartRemainingMs = 0;
    // --- NEXT & HOLD ---
    let nextQueue = [];
    let holdPiece = null;
    let holdUsed = false;
    // 7-bag randomizer
    let bag = [];
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }
    function refillBag() {
      bag = shuffle([1,2,3,4,5,6,7]);
    }
    function drawFromBag() {
      if (bag.length === 0) refillBag();
      return bag.pop();
    }
    function getRandomTetrominoIndex() {
      // Backward compatibility alias to bag draw
      return drawFromBag();
    }
    function fillNextQueue() {
      while (nextQueue.length < 5) {
        nextQueue.push(drawFromBag());
      }
    }
    // --- CANVAS ---
    const canvas = document.getElementById('tetris');
    const context = canvas.getContext('2d');
    const nextCanvas = document.getElementById('next');
    const nextCtx = nextCanvas.getContext('2d');
    const holdCanvas = document.getElementById('hold');
    const holdCtx = holdCanvas.getContext('2d');
    // Add this after: const holdCtx = holdCanvas.getContext('2d');
    var musicEnabled = true;
    const audio = new Audio('Strokinthatshitinbrazil.mp3');
    audio.loop = true;
    audio.preservesPitch = false;
    audio.mozPreservesPitch = false;
    audio.webkitPreservesPitch = false;
    const sfxGameOver = new Audio('fuck-sound-effect-meme.mp3');
    sfxGameOver.loop = false;
    let musicSpeedTimer = 0;
    const MUSIC_SPEED_INTERVAL = 500;
    const MUSIC_OSCILLATION_PERIOD = 8000;
    const MUSIC_MIN_RATE = 0.5;
    const MUSIC_MAX_RATE = 2.0;
    // Line clear messages
    let lineClearMessage = '';
    let lineClearStartTime = 0;
    const LINE_CLEAR_DURATION = 500; // 1.5 seconds
    // --- UTILS ---
    function createMatrix(w, h) {
      const matrix = [];
      while (h--) matrix.push(new Array(w).fill(0));
      return matrix;
    }
    function collide(arena, player) {
      const m = player.matrix;
      const o = player.pos;
      
      for (let y = 0; y < m.length; ++y) {
        for (let x = 0; x < m[y].length; ++x) {
          if (m[y][x]) {
            const newX = x + o.x;
            const newY = y + o.y;
            
            // Strict bounds checking - no piece can ever be outside these bounds
            if (newX < 0 || newX >= COLS || newY >= ROWS) {
              return true; // Hit wall or floor - NO EXCEPTIONS
            }
            
            // Check collision with existing pieces (but allow pieces above the arena during spawn)
            if (newY >= 0 && arena[newY] && arena[newY][newX] !== 0) {
              return true; // Hit existing piece
            }
          }
        }
      }
      return false;
    }
    function merge(arena, player) {
      player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value) {
            // Store tetromino index, not just 1
            arena[y + player.pos.y][x + player.pos.x] = player.tetrominoIndex;
          }
        });
      });
    }
    function drawMatrix(matrix, offset, colorIndex, ctx = context) {
      matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value) {
            ctx.fillStyle = COLORS[colorIndex || value];
            ctx.fillRect((x + offset.x) * BLOCK, (y + offset.y) * BLOCK, BLOCK, BLOCK);
            ctx.strokeStyle = '#222';
            ctx.strokeRect((x + offset.x) * BLOCK, (y + offset.y) * BLOCK, BLOCK, BLOCK);
          }
        });
      });
    }
    function drawPreview(ctx, matrix, colorIndex) {
      ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
      if (!matrix) return;
      // Find bounding box of the tetromino (with I-block special-case handled below)
      let isIBlock = (matrix.length === 4 && matrix[1].every(v => v === 1));
      let offset;
      if (isIBlock) {
        offset = { x: 0, y: 1 };
        if (matrix[1][0] === 1 && matrix[1][1] === 1 && matrix[1][2] === 1 && matrix[1][3] === 1) {
          offset = { x: 0, y: 1 };
        } else {
          offset = { x: 1, y: 0 };
        }
      } else {
        let minX = 4, maxX = -1, minY = 4, maxY = -1;
        matrix.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value) {
              if (x < minX) minX = x;
              if (x > maxX) maxX = x;
              if (y < minY) minY = y;
              if (y > maxY) maxY = y;
            }
          });
        });
        const shapeW = maxX - minX + 1;
        const shapeH = maxY - minY + 1;
        offset = {
          x: Math.floor((4 - shapeW) / 2) - minX,
          y: Math.floor((4 - shapeH) / 2) - minY
        };
      }
      matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value) {
            ctx.fillStyle = COLORS[colorIndex || value];
            ctx.fillRect((x + offset.x) * 24, (y + offset.y) * 24, 24, 24);
            ctx.strokeStyle = '#222';
            ctx.strokeRect((x + offset.x) * 24, (y + offset.y) * 24, 24, 24);
          }
        });
      });
    }
    function drawNextPreviews() {
      nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
      for (let i = 0; i < 3; i++) {
        const idx = nextQueue[i];
        if (idx == null) continue;
        const m = SHAPES[idx];
        if (!m) continue;
        // Create an offscreen 4x4 area within the tall canvas
        nextCtx.save();
        nextCtx.translate(0, i * 96);
        // Centering logic
        let isIBlock = (m.length === 4 && m[1] && m[1].every(v => v === 1));
        let offset;
        if (isIBlock) {
          offset = { x: 0, y: 1 };
          if (m[1][0] === 1 && m[1][1] === 1 && m[1][2] === 1 && m[1][3] === 1) {
            offset = { x: 0, y: 1 };
          } else {
            offset = { x: 1, y: 0 };
          }
        } else {
          let minX = 4, maxX = -1, minY = 4, maxY = -1;
          m.forEach((row, y) => {
            row.forEach((value, x) => {
              if (value) {
                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (y < minY) minY = y;
                if (y > maxY) maxY = y;
              }
            });
          });
          const shapeW = maxX - minX + 1;
          const shapeH = maxY - minY + 1;
          offset = {
            x: Math.floor((4 - shapeW) / 2) - minX,
            y: Math.floor((4 - shapeH) / 2) - minY
          };
        }
        m.forEach((row, y) => {
          row.forEach((value, x) => {
            if (value) {
              nextCtx.fillStyle = COLORS[idx];
              nextCtx.fillRect((x + offset.x) * 24, (y + offset.y) * 24, 24, 24);
              nextCtx.strokeStyle = '#222';
              nextCtx.strokeRect((x + offset.x) * 24, (y + offset.y) * 24, 24, 24);
            }
          });
        });
        nextCtx.restore();
      }
    }
    function drawGrid() {
      context.save();
      context.strokeStyle = 'rgba(255,255,255,0.08)';
      context.lineWidth = 1;
      for (let x = 0; x <= COLS; x++) {
        context.beginPath();
        context.moveTo(x * BLOCK, 0);
        context.lineTo(x * BLOCK, ROWS * BLOCK);
        context.stroke();
      }
      for (let y = 0; y <= ROWS; y++) {
        context.beginPath();
        context.moveTo(0, y * BLOCK);
        context.lineTo(COLS * BLOCK, y * BLOCK);
        context.stroke();
      }
      context.restore();
    }
    // --- MODE STATE ---
    let inMenu = true;
    let gameMode = null; // '40lines' | 'blitz'
    let linesCleared = 0;
    let modeStartedAt = 0;
    let blitzDurationMs = 120000;
    let blitzEndsAt = 0;
    // Speed-up toggle/state
    let autoSpeedEnabled = true;
    const SPEED_DECREMENT_MS = 8;
    const SPEED_MIN_MS = 200;
    const SPEED_INITIAL_MS = 500;

    function setHUD(text) {
      const speedText = ` | Speed-up: ${autoSpeedEnabled ? 'On' : 'Off'}`;
      document.getElementById('modeStatus').textContent = (text || '') + (gameMode ? speedText : '');
    }

    function formatTime(ms) {
      const totalSec = Math.floor(ms / 1000);
      const minutes = Math.floor(totalSec / 60).toString().padStart(2, '0');
      const seconds = (totalSec % 60).toString().padStart(2, '0');
      const hundredths = Math.floor((ms % 1000) / 10).toString().padStart(2, '0');
      return `${minutes}:${seconds}.${hundredths}`;
    }

    function startMode(mode) {
      // Reset core state
      arena = createMatrix(COLS, ROWS);
      player.score = 0;
      gameOver = false;
      holdPiece = null;
      nextQueue = [];
      bag = [];
      linesCleared = 0;
      gameMode = mode;
      inMenu = false;
      paused = false;
      holdUsed = false;
      dropInterval = SPEED_INITIAL_MS;
      // timers
      modeStartedAt = performance.now();
      if (mode === 'blitz') blitzEndsAt = modeStartedAt + blitzDurationMs;
      // Start music
      if (musicEnabled) {
        audio.currentTime = 0;
        audio.playbackRate = 1.0;
        audio.preservesPitch = false;
        audio.mozPreservesPitch = false;
        audio.webkitPreservesPitch = false;
        audio.play();
        musicSpeedTimer = 0;
      }
      playerReset();
      updateScore();
      updateHUDForMode();
    }

    function endMode(message) {
      paused = true;
      setHUD(message);
      // Stop music
      audio.pause();
      // Return to menu after a short delay
      setTimeout(() => {
        inMenu = true;
        paused = false;
        gameMode = null;
        setHUD('');
      }, 1200);
    }

    function updateHUDForMode() {
      if (gameMode === '40lines') {
        const elapsed = performance.now() - modeStartedAt;
        setHUD(`40 Lines: ${linesCleared}/40 | Time: ${formatTime(elapsed)}`);
      } else if (gameMode === 'blitz') {
        const remaining = Math.max(0, blitzEndsAt - performance.now());
        const totalSec = Math.ceil(remaining / 1000);
        const minutes = Math.floor(totalSec / 60).toString().padStart(1, '0');
        const seconds = (totalSec % 60).toString().padStart(2, '0');
        setHUD(`Blitz: ${minutes}:${seconds} left | Lines: ${linesCleared}`);
      } else {
        setHUD('');
      }
    }

    function getElapsedMsForMode() {
      if (!gameMode) return 0;
      if (gameMode === 'blitz') return Math.max(0, performance.now() - modeStartedAt);
      return performance.now() - modeStartedAt;
    }
    function formatStats() {
      const elapsed = getElapsedMsForMode();
      return `Score: ${player.score}\nLines: ${linesCleared}\nTime: ${formatTime(elapsed)}`;
    }
    function handleGameOver() {
      // Stop music and play SFX
      try { audio.pause(); } catch(e) {}
      try { sfxGameOver.currentTime = 0; sfxGameOver.play(); } catch(e) {}
      // Show stats
      alert('get fucked\n' + formatStats());
      // Return to menu
      performRestart();
    }

    function handleWin() {
      // Stop music
      try { audio.pause(); } catch(e) {}
      // Show stats
      alert('You Win!\n\n' + formatStats());
      // Return to menu
      performRestart();
    }

    // Hook up menu buttons after DOM is ready
    document.getElementById('btn40').addEventListener('click', () => startMode('40lines'));
    document.getElementById('btnBlitz').addEventListener('click', () => startMode('blitz'));
    const toggleSpeedEl = document.getElementById('toggleSpeed');
    toggleSpeedEl.checked = autoSpeedEnabled;
    toggleSpeedEl.addEventListener('change', () => {
      if (!toggleSpeedEl.checked) {
        const phrase = prompt('Type exactly: "I am a faggot" to disable speed-up');
        if (phrase === 'I am a faggot') {
          autoSpeedEnabled = false;
        } else {
          toggleSpeedEl.checked = true;
          autoSpeedEnabled = true;
        }
      } else {
        autoSpeedEnabled = true;
      }
      updateHUDForMode();
    });
    const toggleMusicEl = document.getElementById('toggleMusic');
    toggleMusicEl.addEventListener('change', () => {
      musicEnabled = toggleMusicEl.checked;
      if (!musicEnabled) {
        audio.pause();
      } else if (!inMenu && gameMode) {
        audio.play();
      }
    });

    function draw() {
      // Toggle menu visibility
      document.getElementById('startMenu').style.display = inMenu ? 'block' : 'none';
      context.fillStyle = '#222';
      context.fillRect(0, 0, COLS * BLOCK, ROWS * BLOCK);
      drawGrid();
      arena.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value) {
            context.fillStyle = COLORS[value];
            context.fillRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
            context.strokeStyle = '#222';
            context.strokeRect(x * BLOCK, y * BLOCK, BLOCK, BLOCK);
          }
        });
      });
      if (player.matrix && !inMenu) drawMatrix(player.matrix, player.pos, player.tetrominoIndex);
      // Draw next (top 3) and hold previews
      drawNextPreviews();
      drawPreview(holdCtx, holdPiece ? SHAPES[holdPiece] : null, holdPiece);
      // Restart hold overlay
      if (restartHoldActive) {
        const secs = Math.ceil(restartRemainingMs / 1000);
        context.save();
        context.globalAlpha = 0.75;
        context.fillStyle = '#000';
        context.fillRect(0, ROWS * BLOCK / 2 - 60, COLS * BLOCK, 120);
        context.globalAlpha = 1;
        context.fillStyle = '#fff';
        context.font = 'bold 22px sans-serif';
        context.textAlign = 'center';
        context.fillText(`Hold R to restart: ${secs}`, COLS * BLOCK / 2, ROWS * BLOCK / 2 - 10);
        const barW = COLS * BLOCK * (1 - (restartRemainingMs / restartHoldMs));
        context.fillStyle = '#0DC2FF';
        context.fillRect(0, ROWS * BLOCK / 2 + 10, barW, 12);
        context.strokeStyle = '#fff';
        context.strokeRect(0, ROWS * BLOCK / 2 + 10, COLS * BLOCK, 12);
        context.restore();
      }
      if (paused && !inMenu) {
        context.save();
        context.globalAlpha = 0.7;
        context.fillStyle = '#000';
        context.fillRect(0, ROWS * BLOCK / 2 - 40, COLS * BLOCK, 80);
        context.globalAlpha = 1;
        context.fillStyle = '#fff';
        context.font = 'bold 36px sans-serif';
        context.textAlign = 'center';
        context.fillText('Paused', COLS * BLOCK / 2, ROWS * BLOCK / 2 + 12);
        context.restore();
      }
      // Draw line clear message
      if (lineClearMessage && !inMenu) {
        const elapsed = performance.now() - lineClearStartTime;
        if (elapsed < LINE_CLEAR_DURATION) {
          const alpha = Math.min(1, 3 * (1 - elapsed / LINE_CLEAR_DURATION));
          context.save();
          context.globalAlpha = alpha;
          context.fillStyle = '#fff';
          context.font = 'bold 24px sans-serif';
          context.textAlign = 'center';
          context.fillText(lineClearMessage, COLS * BLOCK / 2, ROWS * BLOCK / 2 - 20);
          context.restore();
        } else {
          lineClearMessage = '';
        }
      }
    }
    // --- Only reset holdUsed after piece locks and new one spawns ---
    function playerDrop() {
      player.pos.y++;
      if (collide(arena, player)) {
        player.pos.y--;
        merge(arena, player);
        arenaSweep();
        // Speed up after piece locks
        if (autoSpeedEnabled) {
          dropInterval = Math.max(SPEED_MIN_MS, dropInterval - SPEED_DECREMENT_MS);
        }
        playerReset();
        updateScore();
        if (collide(arena, player)) {
          handleGameOver();
        }
        holdUsed = false; // Only reset hold after piece locks
      }
      dropCounter = 0;
    }
    function playerMove(dir) {
      player.pos.x += dir;
      if (collide(arena, player)) {
        player.pos.x -= dir;
      }
    }
    function playerRotate() {
      const originalMatrix = player.matrix;
      const originalPos = { ...player.pos };
      const originalRotation = player.rotation;
      
      // Create rotated matrix
      const rotatedMatrix = rotate(originalMatrix);
      
      // ALWAYS try basic rotation first
      const basicTest = { 
        ...player, 
        matrix: rotatedMatrix,
        pos: { ...player.pos } 
      };
      
      if (!collide(arena, basicTest)) {
        player.matrix = rotatedMatrix;
        player.rotation = (player.rotation + 1) % 4;
        return;
      }
      
      // If basic rotation fails, try ALL wall kicks
      const kicks = getWallKicks(originalMatrix, rotatedMatrix, originalRotation);
      
      for (let i = 0; i < kicks.length; i++) {
        const [dx, dy] = kicks[i];
        const testPlayer = {
          ...player,
          matrix: rotatedMatrix,
          pos: { x: player.pos.x + dx, y: player.pos.y + dy }
        };
        
        // Double-check the test position is valid
        if (!collide(arena, testPlayer)) {
          player.matrix = rotatedMatrix;
          player.pos.x += dx;
          player.pos.y += dy;
          player.rotation = (player.rotation + 1) % 4;
          return;
        }
      }
      
      // If NO rotation works, keep original position (no rotation at all)
      // This is safer than allowing any clipping
    }
    function rotate(matrix, reverse) {
      for (let y = 0; y < matrix.length; ++y) {
        for (let x = 0; x < y; ++x) {
          [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
        }
      }
      if (reverse) {
        matrix.forEach(row => row.reverse());
      } else {
        matrix.reverse();
      }
      return matrix;
    }
    function arenaSweep() {
      let rowCount = 1;
      let cleared = 0;
      outer: for (let y = arena.length - 1; y >= 0; --y) {
        for (let x = 0; x < arena[y].length; ++x) {
          if (arena[y][x] === 0) continue outer;
        }
        const row = arena.splice(y, 1)[0].fill(0);
        arena.unshift(row);
        ++y;
        player.score += rowCount * 10;
        rowCount *= 2;
        cleared += 1;
      }
      if (cleared > 0) linesCleared += cleared;
      // Set line clear message
      if (cleared === 2) {
        lineClearMessage = 'double :3';
        lineClearStartTime = performance.now();
      } else if (cleared === 3) {
        lineClearMessage = 'triple :3';
        lineClearStartTime = performance.now();
      } else if (cleared === 4) {
        lineClearMessage = 'tetris :3';
        lineClearStartTime = performance.now();
      }
    }
    function playerReset() {
      fillNextQueue();
      const tetrominoIndex = nextQueue.shift();
      player.matrix = SHAPES[tetrominoIndex].map(row => row.slice());
      player.color = COLORS[tetrominoIndex];
      player.tetrominoIndex = tetrominoIndex;
      player.pos.y = 0;
      player.pos.x = ((COLS / 2) | 0) - ((player.matrix[0].length / 2) | 0);
      holdUsed = false;
      fillNextQueue();
      if (collide(arena, player)) {
        handleGameOver();
      }
    }
    function playerHold() {
      if (holdUsed) return;
      holdUsed = true;
      if (holdPiece == null) {
        holdPiece = player.tetrominoIndex;
        playerReset();
      } else {
        // Swap
        let temp = player.tetrominoIndex;
        player.matrix = SHAPES[holdPiece].map(row => row.slice());
        player.color = COLORS[holdPiece];
        player.tetrominoIndex = holdPiece;
        player.pos.y = 0;
        player.pos.x = ((COLS / 2) | 0) - ((player.matrix[0].length / 2) | 0);
        holdPiece = temp;
        if (collide(arena, player)) {
          handleGameOver();
        }
      }
    }
    function updateScore() {
      document.getElementById('score').textContent = 'Score: ' + player.score;
    }
    // --- MOVEMENT DELAY ---
    let moveLeftHeld = false, moveRightHeld = false, softDropHeld = false;
    let moveLeftTimer = 0, moveRightTimer = 0, softDropTimer = 0;
    const MOVE_INITIAL_DELAY = 120; // ms before repeat starts
    const MOVE_REPEAT = 60; // ms between moves when holding
    function handleMoveTimers(deltaTime) {
      if (moveLeftHeld) {
        moveLeftTimer -= deltaTime;
        if (moveLeftTimer <= 0) {
          playerMove(-1);
          moveLeftTimer = MOVE_REPEAT;
        }
      }
      if (moveRightHeld) {
        moveRightTimer -= deltaTime;
        if (moveRightTimer <= 0) {
          playerMove(1);
          moveRightTimer = MOVE_REPEAT;
        }
      }
      if (softDropHeld) {
        softDropTimer -= deltaTime;
        if (softDropTimer <= 0) {
          playerDrop();
          softDropTimer = MOVE_REPEAT;
        }
      }
    }
    function update(time = 0) {
      if (inMenu) {
        draw();
        requestAnimationFrame(update);
        return;
      }
      if (gameOver) return;
      if (paused) {
        if (restartHoldActive) {
          const now = performance.now();
          restartRemainingMs = Math.max(0, restartHoldMs - (now - restartHoldStart));
          if (restartRemainingMs === 0) { performRestart(); restartHoldActive = false; }
        }
        updateHUDForMode();
        draw();
        requestAnimationFrame(update);
        return;
      }
      const deltaTime = time - lastTime;
      lastTime = time;
      dropCounter += deltaTime;
      handleMoveTimers(deltaTime);
      if (dropCounter > dropInterval) playerDrop();
      // Update restart hold countdown
      if (restartHoldActive) {
        const now = performance.now();
        restartRemainingMs = Math.max(0, restartHoldMs - (now - restartHoldStart));
        if (restartRemainingMs === 0) { performRestart(); restartHoldActive = false; }
      }
      // Update music speed
      if (musicEnabled && !paused) {
        musicSpeedTimer += deltaTime;
        // Oscillate between 0.5x and 2.0x using sine wave
        const oscillationProgress = (musicSpeedTimer % MUSIC_OSCILLATION_PERIOD) / MUSIC_OSCILLATION_PERIOD;
        const sineValue = Math.sin(oscillationProgress * 2 * Math.PI);
        const range = MUSIC_MAX_RATE - MUSIC_MIN_RATE;
        const center = (MUSIC_MAX_RATE + MUSIC_MIN_RATE) / 2;
        audio.playbackRate = center + (sineValue * range / 2);
      }
      // Update mode HUD and end conditions
      if (gameMode === '40lines') {
        updateHUDForMode();
        if (linesCleared >= 40) {
          handleWin();
        }
      } else if (gameMode === 'blitz') {
        updateHUDForMode();
        if (performance.now() >= blitzEndsAt) {
          alert('Blitz Complete!\n\n' + formatStats());
          performRestart();
        }
      }
      draw();
      requestAnimationFrame(update);
    }
    function performRestart() {
      // On restart, return to the mode selection menu
      inMenu = true;
      gameMode = null;
      restartHoldActive = false;
      restartRemainingMs = 0;
      paused = false;
      // Stop music
      audio.pause();
      // Reset core state
      arena = createMatrix(COLS, ROWS);
      player.score = 0;
      gameOver = false;
      holdPiece = null;
      nextQueue = [];
      bag = [];
      linesCleared = 0;
      holdUsed = false;
      dropInterval = SPEED_INITIAL_MS;
      updateScore();
      moveLeftHeld = moveRightHeld = softDropHeld = false;
      moveLeftTimer = moveRightTimer = softDropTimer = 0;
      setHUD('');
      // Re-enable speed-up for next match
      autoSpeedEnabled = true;
      document.getElementById('toggleSpeed').checked = true;
    }
    document.addEventListener('keydown', event => {
      if (event.key.toLowerCase() === 'p') {
        paused = !paused;
        if (!paused) lastTime = performance.now();
        draw();
        return;
      }
      if (event.key.toLowerCase() === 'r') {
        if (!restartHoldActive) {
          restartHoldActive = true;
          restartHoldStart = performance.now();
          restartRemainingMs = restartHoldMs;
        }
        return;
      }
      if (inMenu) return; // block gameplay keys while in menu
      if (gameOver) return;
      if (event.key === 'ArrowLeft') {
        if (!moveLeftHeld) {
          playerMove(-1);
          moveLeftHeld = true;
          moveLeftTimer = MOVE_INITIAL_DELAY; // initial delay
        }
      } else if (event.key === 'ArrowRight') {
        if (!moveRightHeld) {
          playerMove(1);
          moveRightHeld = true;
          moveRightTimer = MOVE_INITIAL_DELAY;
        }
      } else if (event.key === 'ArrowDown') {
        if (!softDropHeld) {
          playerDrop();
          softDropHeld = true;
          softDropTimer = MOVE_INITIAL_DELAY;
        }
      } else if (event.key === 'ArrowUp') {
        playerRotate();
      } else if (event.key === ' ') {
        // Hard drop
        while (!collide(arena, player)) {
          player.pos.y++;
        }
        player.pos.y--;
        playerDrop();
      } else if (event.key === 'Shift' || event.key.toLowerCase() === 'c') {
        playerHold();
      }
    });
    document.addEventListener('keyup', event => {
      if (event.key.toLowerCase() === 'r') {
        restartHoldActive = false;
        restartRemainingMs = 0;
      }
      if (event.key === 'ArrowLeft') moveLeftHeld = false;
      if (event.key === 'ArrowRight') moveRightHeld = false;
      if (event.key === 'ArrowDown') softDropHeld = false;
    });
    // --- START GAME ---
    // nextQueue = [];
    // holdPiece = null;
    // playerReset();
    updateScore();
    update();
    document.getElementById('error').textContent = '';
  </script>
</body>
</html>
